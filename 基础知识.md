# 基础知识

#### 1.异或运算

**规则:**

位相同为0,不同为1

```go
46		1 0 1 1 1 0
0		0 0 0 0 0 0
--------------------
46		1 0 1 1 1 0


46		1 0 1 1 1 0
46		1 0 1 1 1 0
--------------------
0		0 0 0 0 0 0


46		1 0 1 1 1 0
53		1 1 0 1 0 1
--------------------
27		0 1 1 0 1 1
46		1 0 1 1 1 0
--------------------
53		1 1 0 1 0 1
```



**性质:**

1. 任何数和 00 做异或运算，结果仍然是原来的数，即 a^0=a。
2. 任何数和其自身做异或运算，结果是 00，即 a^a=0。
3. 异或运算满足交换律和结合律，即 a^b^a=b^a^a=b^(a^a)=b^0=b。



#### 2.约瑟夫环

**规则:**

已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为1的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。找到最后一个出列人的编号。

**性质:**

```go
func Josephus(n, m int) int {
	index := 0
	for i := 2; i < n; i++ {
		index = (index + m) % i
	}
    //编号
	return index+1
}
```



#### 3.KMP算法

**描述:**

从目标字符串中**快速**找到目标子串

**思想:**

找到子串中的公共前缀和后缀,实现在查找时快速定位下次匹配位置,减少匹配次数

```go
	0	1 	2	3	4	5	6	7	8	9	10	11	12
		A	B	A	B	A	A	A	B	A	B	A	A
NEXT	0	1	1	2	3	4	2	2	3	4	5	6

规律:NEXT数组中存放当前位置前 相同前后缀长度+1
```



#### 4.移位合并与拆解

```go
//2 3 => 131075
func Splice(zoneid uint16, hostId uint32) uint32 {
    //zoneid 只有16位,再左移16位会溢出
    //所以要先扩容到32位再移位
    //0000 0000 0000 0010 0000 0000 0000 0000 uint32(zoneid)<<16 = 131072
    //0000 0000 0000 0000 0000 0000 0000 0011 hostId = 3
    //----------------------------------------------- |(或运算)
    //0000 0000 0000 0010 0000 0000 0000 0011 = 131075
	return uint32(zoneid)<<16 | hostId
}

//131075 -> 2 3
func Split(hostId uint32) Pair {
    //First:
    //0000 0000 0000 0010 0000 0000 0000 0011 >> 16 (只取前16位)
    //----------------------------------------------
    //0000 0000 0000 0010 = 2
    //转换到16位uint保存
    
    //Second:
    //0000 0000 0000 0010 0000 0000 0000 0011 hostId = 131075
    //0000 0000 0000 0000 1111 1111 1111 1111 0x0000ffff = 65535
    //----------------------------------------------- &(与运算)
    //0000 0000 0000 0000 0000 0000 0000 0011 = 3
    return Pair{First: uint16(hostId >> 16), Second: hostId & 0x0000ffff}
}
```

**总结规律:**

`<<`:左移时需要考虑是否溢出,必要时扩大数据长度后再移位

`>>`:右移时也需要考虑是否溢出,移完数据后可以选择保存到合适的数据大小中

`|`:或运算在进行移位合并的操作时,作用是合并数据.利用遇1则1的特性,利用高位低位差将数据合并起来,注意两个数据之间的位不能有冲突.

`&`:与运算在进行移位合并的操作时,作用是拆分数据,利用遇0则0的特性,将想要取得的位数置为1后与原数据进行与运算就可以拿到对应位的数据.



#### 5.BitMap

Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。

![img](.\picture\874963-20190930161508728-1545815203.png)

这样的话，好像变成一个二维数组了

1个int占32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32] 即可存储，其中N表示要存储的这些数中的最大值，于是乎：

tmp[0]：可以表示0~31

tmp[1]：可以表示32~63

tmp[2]：可以表示64~95

...

如此一来，给定任意整数M，那么M/32就得到下标，M%32就知道它在此下标的哪个位置



##### 添加:

这里有个问题，我们怎么把一个数放进去呢？例如，想把5这个数字放进去，怎么做呢？

首先，5/32=0，5%32=5，也是说它应该在tmp[0]的第5个位置，那我们把1向左移动5位，然后按位或

![img](.\picture\874963-20190930170044824-1061422457.png)

```go
0101 0110 = 86
0010 0000 = |32
-------------
0111 0110 = 118

86|32 = 86|(1<<5)
b[0] = b[0]|(1<<5)
86 + (5/8) | (1<<(5%8))

公式:
 b[i/8] + (i/8)|(1<<(i%8)) 其中，p表示现在的值，i表示待插入的数
```



##### 删除:

移除6

##### ![img](.\picture\874963-20191013123453790-20308625.png)

```go
b[0] = b[0] & (~(1<<6))

公式:
b[i/8] = b[i/8] & (~(1<<(i%8)))
```



##### 查找:

想知道3在不在，那么只需判断 b[0] & (1<<3) 如果这个值是0，则不存在，如果是1，就表示存在

```go

公式:
b[i/8]&(1<<(i%8)) //1存在 0不存在
```



##### 快速排序:

假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。

要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，然后将对应位置为1。

最后，遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。

优点：

- 运算效率高，不需要进行比较和移位；
- 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M

缺点：

- 所有的数据不能重复。即不可对重复的数据进行排序和查找。
- 只有当数据比较密集时才有优势



##### 快速去重:

20亿个整数中找出不重复的整数的个数，内存不足以容纳这20亿个整数。 

首先，根据“内存空间不足以容纳这05亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这20亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间2G左右。

接下来的任务就是把这20亿个数字放进去（存储），如果对应的状态位为00，则将其变为01，表示存在一次；如果对应的状态位为01，则将其变为11，表示已经有一个了，即出现多次；如果为11，则对应的状态位保持不变，仍表示出现多次。

最后，统计状态位为01的个数，就得到了不重复的数字个数，时间复杂度为O(n)。



##### 小结&回顾

Bitmap主要用于快速检索关键字状态，通常要求关键字是一个连续的序列（或者关键字是一个连续序列中的大部分）， 最基本的情况，使用1bit表示一个关键字的状态（可标示两种状态），但根据需要也可以使用2bit（表示4种状态），3bit（表示8种状态）。

Bitmap的主要应用场合：表示连续（或接近连续，即大部分会出现）的关键字序列的状态（状态数/关键字个数 越小越好）。

32位机器上，对于一个整型数，比如int a=1 在内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的32bit位对应存储十进制的0-31个数，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。



##### 补充1

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方，右移一位相当于除2，右移n位相当于除以2的n次方。

<< 左移，相当于乘以2的n次方，例如：1<<6  相当于1×64=64，3<<4 相当于3×16=48

\>> 右移，相当于除以2的n次方，例如：64>>3 相当于64÷8=8

^ 异或，相当于求余数，例如：48^32 相当于 48%32=16



##### 补充2

不使用第三方变量，交换两个变量的值

```go
1 // 方式一
2 a = a + b;
3 b = a - b;
4 a = a - b;
5 
6 // 方式二
7 a = a ^ b;
8 b = a ^ b;
9 a = a ^ b;
```