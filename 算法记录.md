# 算法记录

## 数组相关

#### 有效数独

**规则:**

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

![img](.\picture\250px-sudoku-by-l2g-20050714svg.png)

```go
func main() {
	test := [][]byte{
		{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
		{'6', '.', '.', '1', '9', '5', '.', '.', '.'},
		{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
		{'8', '.', '.', '.', '6', '.', '.', '.', '3'},
		{'4', '.', '.', '8', '.', '3', '.', '.', '1'},
		{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
		{'.', '6', '.', '.', '.', '.', '2', '8', '.'},
		{'.', '.', '.', '4', '1', '9', '.', '.', '5'},
		{'.', '.', '.', '.', '8', '.', '.', '7', '9'},
	}
	fmt.Println(isValidSudoku(test))
}

func isValidSudoku(board [][]byte) bool {
    /**
	rows 记录每行出现的数字
	cols 记录每列出现的数字
	boxes 记录每个分组出现的数字
	*/
	var rows, cols, boxes [9][9]bool

	for i, row := range board {
		for j, col := range row {
			if col != '.' {
                //计算此值与'1'间的距离,记作下标
				index := col - '1'
                //查看此值是否已记录过
				if rows[i][index] || cols[j][index] || boxes[i/3*3+j/3][index] {
					return false
				}
				rows[i][index] = true
				cols[j][index] = true
				boxes[i/3*3+j/3][index] = true
			}
		}
	}
	return true
}
```



#### 买卖股票的最佳时机 II

**规则:**

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```go
//动态规划
func maxProfit1(prices []int) int {
	/**
	nohold 当天不持有股票时的收益
	hold 当天持有股票时的收益
	*/
	//第一天不买或买入的情况
	nohold, hold := 0, -prices[0]

	for i, price := range prices {
		if i == 0 {
			continue
		}
		//取最大值(保持不持有/卖掉手中持有股票)
		nohold = max(nohold, hold+price)
		//取最大值(保持持有/买当天股票)
		hold = max(hold, nohold-price)
	}
	//一定是不持有的情况下收益最大
	return nohold
}

//贪心算法
func maxProfit2(prices []int) int {
	if len(prices) < 2 {
		return 0
	}
	/**
	total 总收益
	index 当前下标
	length 数组长度
	 */
	total, index, length := 0, 0, len(prices)

	for ; index < length; {
		//如果股票下跌就一直找，直到找到股票开始上涨为止
		for ; index < length-1 && prices[index] >= prices[index+1]; {
			index++
		}
		//记录上涨前的最小值
		min := prices[index]
		//一直找到股票上涨的最大值为止
		for ; index < length-1 && prices[index] <= prices[index+1]; {
			index++
		}
		//计算差值后累加
		total += prices[index] - min
		index++
	}
	return total
}
```



#### 旋转数组

**规则:**

给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？

```go
//1.使用额外的数组
func rotate1(nums []int, k int) {
    newNums := make([]int, len(nums))
    for i, v := range nums {
        newNums[(i+k)%len(nums)] = v
    }
    copy(nums, newNums)
}


//2.环状替换
func rotate2(nums []int, k int) {
    n := len(nums)
    k %= n
    for start, count := 0, gcd(k, n); start < count; start++ {
        pre, cur := nums[start], start
        for ok := true; ok; ok = cur != start {
            next := (cur + k) % n
            nums[next], pre, cur = pre, nums[next], next
        }
    }
}
//最大公约数
func gcd(a, b int) int {
    for a != 0 {
        a, b = b%a, a
    }
    return b
}


//3.数组翻转
func rotate3(nums []int, k int) {
    k %= len(nums)
    reverse(nums)
    reverse(nums[:k])
    reverse(nums[k:])
}

func reverse(a []int) {
    for i, n := 0, len(a); i < n/2; i++ {
        a[i], a[n-1-i] = a[n-1-i], a[i]
    }
}
```



#### 删除排序数组中的重复项

**规则:**

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```go
func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
    //初始一个下标,从1开始,因为0不用替换
	i:=1
	for j := 1; j < len(nums); j++{
        //如果当前元素和之前元素不同,把此元素放到自定义下标位置
		if nums[j] != nums[j-1] {
			nums[i] = nums[j]
			i++
		}
	}
	return i
}
```



#### 存在重复元素

给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

```go
func containsDuplicate(nums []int) bool {
    //此map作用与set相同
    m:=make(map[int]struct{})
    for _,v:=range nums{
        if _,ok:=m[v];ok{
            return true
        }
        m[v] = struct{}{}
    }
    return false
}
```



#### 只出现一次的数字

**规则:**

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```go
func singleNumber(nums []int) int {
    var i int
    for _,v:=range nums {
        //异或运算中,相同元素异或会变为0,与0异或变为本身
        //即a^b^a = b
        i ^=v
    }
    return i
}
```



#### 两个数组的交集 II

**规则:**

给定两个数组，编写一个函数来计算它们的交集。

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

```go
//1.双指针
func intersect1(nums1 []int, nums2 []int) []int {
    //对两个数组排序
	sort.Ints(nums1)
	sort.Ints(nums2)
    
    //初始化两个下标
	i, j := 0, 0
    
	var collection []int
    //从小到大遍历
	for i < len(nums1) && j < len(nums2) {
		if nums1[i] == nums2[j] {
            //相等的值放入新数组中
			collection = append(collection, nums1[i])
			i++
			j++
		} else if nums1[i] > nums2[j] {//不相等的情况下,值较小的数组下标移动
			j++
		} else {
			i++
		}
	}
	return collection
}


//2.哈希表
func intersect2(nums1 []int, nums2 []int) []int {
	var collection []int
	m := make(map[int]int)
    //遍历nums1存储出现过的值并记录出现次数
	for _, v := range nums1 {
		m[v]++
	}
	//遍历nums2
	for _, v := range nums2 {
        //如果map中有此键并且剩余次数大于0,则说明可取
		if num, ok := m[v]; ok && num > 0 {
			collection = append(collection, v)
            //用掉一次
			m[v]--
		}
	}
	return collection
}
```

